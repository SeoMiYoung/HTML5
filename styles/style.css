@import url(./normalize.css); /*반드시 첫줄, 또한 RESET보다 먼저 */
@import url(./reset.css); 

/* 기본 스타일 */
*, *::before, *::after {
  box-sizing: border-box; /*모든 요소를 border-box로 할건지 통일하는게 좋음*/
  /* 등장하는 모든 요소들의 box-sizing방식을 통일하겠다!! */
}

/* 본문 스타일 */
body {
  background:#ffc;
  font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, Roboto, "Helvetica Neue", "Segoe UI", "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  font-weight: 400;  
}

/* 레이아웃 */
.header, .visual, .main, .slogan, .footer-inner {
  width: 940px;
  margin: 0 auto;
  
}
/* 헤더 */
.header {
  background:pink;
  height: 15vh;  /*브라우저의 비율에 따라 15%*/
  padding: 0 30px;   /* header에서만 padding을 사용할거야 */
}

/* 비주얼 */
.visual {
  background:orange;
  height: 10vh;
}

/* 메인 */
.main {
  background:lightgreen;
  height: 50vh; 
  display: flow-root; /*  
    - float의 부모에다가 줘야함, 익스플로러, 레거시 환경은 지원불가 
    - 전통방법아님. 모던 방식
    - 이 경우, relative를 써서, 레이아웃을 벗어나더라도 벗어난 영역을 확인 가능
  */
  /* overflow: hidden;  
    - 마찬가지로 float의 부모에 쓴다. 가장 많이 쓰는 방법 
    - IE6에서 작동되지 않았음
    - 현재도 협업에서 많이 사용 but, overflow는 잠재적인 위험 존재
      -> position: static이 기본값인데, position: relative로 설정하는 순간
         움직일수가 있게 됨. 
      -> .group1에다가 'position: relative; left: -100px;'하는 순간, 제자리에서 왼쪽으로 이동
         근데 이동했는데, group1의 부모인 main이 overflow로 되어있으니, 레이아웃에서 벗어난 영역이 hidden됨
    - overflow: auto 는 넘치는 영역에 대한 걸 스크롤바로 알려줌
    - 즉, overflow를 쓰기 위해서는 
         1) 부모의 width, height값을 알아야 함
         2) 내부의 자식요소의 컨텐츠 길이를 알아야 자를건지, 스크롤바를 제공할지 알아야 함
         -> 결국, overflow라는 속성을 주는 순간, 독립적인 블록 formating contexting 영역으로 인식됨
    - 그래서, group들의 부모에 overflow:hidden속성을 줘서, 자식들(group)에 대한 잃어버린 높이 속성을
      다시 읽어들이게 해서, 높이를 유지하게 하는거야
  */ 
  /* zoom: 1;  
    - IE6의 경우, overflow를 사용할 때 필요
    - 숫자1의 100%라는 의미. 원본 크기를 확인하는거임 in IE6
    - 그러나, IE는 이제 죽어서, 이제 ZOOM안써도 됨 
  */
  padding: 0 15px;
}

.group {
  margin: 0 15px;
  float: left;
}

.group1 {
  background: violet; /*마찬가지로 영역 구분을 위해 임의로 색 지정*/
  width: 250px;
  /* position: relative; 
    - relative의 경우, 현재 자신의 위치를 기준으로 움직임 
    left: -100px;
  */

}

.group2 {
  background: salmon;  /*마찬가지로 영역 구분을 위해 임의로 색 지정*/
  width: 380px;
}

.group3 {
  background: gold;  /*마찬가지로 영역 구분을 위해 임의로 색 지정*/
  width: 190px;
}

/* clear속성을 동작시키기 위해, 가짜 요소를 항상 float 마지막에 삽입 */
.clearfix {
  clear: both/*
    - float를 해제하는 속성
    - clear: left -> float left해제
    - clear: right
    - clear: both -> 양쪽 해제
    -> 갑자기 float요소의 높이 만큼을 읽어들여요
    - but, clear속성은 블록성격요소에만 적용가능이다, inline성격은 적용이 안된다
      -> 그러면 적용하고 싶으면 블록요소로 바꿔야겠네
  */
}

/*
.main::after {  그러나.. 얘도 요소라고 생각해서 정렬에 문제가 생길 수 있어
  content: "";
  clear: both;
  display: block;  clear사용하기 위해 
} 
*/

/* 슬로건 */
.slogan {
  background:skyblue;
  height: 10vh;
}

/* 푸터 - 사실상 배경(그라데이션)을 위한 태그 */
.footer {
  background:gray;
  height: 15vh;
}

/* 푸터 이너 - footer태그 속의 content들을 넣기 위한 태그 */
.footer-inner {
  height:15vh;
  background: silver;
}

